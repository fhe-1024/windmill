#事务
事务，大家所熟悉的事务(Transaction),基本上就会往Spring事务靠。其实Spring事务管理基于底层数据库本身的事务处理机制。数据库事务的基础，是掌握Spring事务管理的基础。
##数据库事务
它的思想：we are family。就是多个SQL语句(一个团队)，要么所有执行success,要么fail。  
它最终的目标：数据不会被破坏。即：事务操作成功，数据库的结果和业务期待的结果是一致的。这也就是ACID中的一致性(Consistency)。那么什么是ACID呢？
###ACID
* 原子性(Atomicity)  
	  >**原子是物质的最小单元，即不可再分**  
      **一个事务应该被当做单独的执行单元，意味着全部的操作序列全部成功或全部失败。**  
	  **如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生转换；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换。**  
    
* 一致性(Consistency)  
	 >**终极目标：数据不会被破坏。（这不是废话？确实有点）具体说，事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。举个栗子：两句UPDATE语句，从A账户转账到B账户，不管成功失败，A和B账户的总额是不变的。**  
		
* 隔离性(Isolation)  
	 >**隔离：表示互不干扰。事务与事务之间无法干扰，即每个事务独立，不会交叉。这样可以让多个线程并发访问数据库。**  
	 但是聪明的小伙伴知道，如果事务完全隔离，每次只允许一个事务能访问数据库，那其他都是阻塞。会非常慢。  
	 但是聪明的小伙伴也知道，这样会造成数据的并发问题  
	 * 脏读：A事务读取了B事务未提交的更改数据。一般数据库事务默认不允许该问题出现。
	 * 不可重复读：A事务读取了B事务已提交的更改数据。
	 * 幻读：A事务读取了B事务提交的新增数据。

	**不可重复读和幻读区别：一个更改，一个新增数据。其实两个区别在于一个是新增（insert语句），处理幻读这个操作需要加表级别的锁，将整个表锁定，防止新增数据造成幻读。另一个则是更改（update delete），这时候避免这个情况只需要添加行级锁组织该行发生变化即可。**
* 持久性(Durability)  
	 >**数据必须持久化到数据库（存储在磁盘）中。已提交的事务，即使在提交后数据库崩溃，重启数据库时也能够根据日志对未持久化的数据进行重执行操作。（同学会问，那没提交的事务呢？那就悲剧了(＞﹏＜)）**




##propagation
事物的传播属性  
事务的第一个方面是传播行为。传播行为定义关于客户端和被调用方法的事务边界。Spring定义了7中传播行为。 

| 传播行为                    | 意义   |
| -------------------------- | -----|
| PROPAGATION_MANDATORY      | 表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常 |
| PROPAGATION_NESTED         |表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样。|
|PROPAGATION_NEVER           |表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。|
|PROPAGATION_NOT_SUPPORTED   |表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。|
|PROPAGATION_SUPPORTS        |表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。|
|PROPAGATION_REQUIRES_NEW    |表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。|
|PROPAGATION_REQUIRES        |表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。|

##isolation
事物的隔离属性
声明式事务的第二个方面是隔离级别。隔离级别定义一个事务可能受其他并发事务活动活动影响的程度。另一种考虑一个事务的隔离级别的方式，是把它想象为那个事务对于事物处理数据的自私程度。  
在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常牵扯到锁定在数据库中的记录（而且有时是锁定完整的数据表）。侵占性的锁定会阻碍并发，要求事务相互等待来完成工作。  
考虑到完全隔离会影响性能，而且并不是所有应用程序都要求完全隔离，所以有时可以在事务隔离方面灵活处理。因此，就会有好几个隔离级别。  

| 隔离级别                     | 意义                           |
|---------------------------- |------------------------------ |
| ISOLATION_DEFAULT           | 使用后端数据库默认的隔离级别。     |
| ISOLATION_READ_UNCOMMITTED   |允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。|
| ISOLATION_READ_COMMITTED    |允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。|
|ISOLATION_REPEATABLE_READ    |相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。|
|ISOLATION_SERIALIZABLE       |完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。|
